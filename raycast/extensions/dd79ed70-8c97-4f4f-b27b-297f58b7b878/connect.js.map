{
  "version": 3,
  "sources": ["../src/connect.tsx", "../src/lib.ts"],
  "sourcesContent": ["import { PopToRootType, Toast, showHUD, showToast } from \"@raycast/api\";\nimport { ConnectionStatus, connectToWarp, getWarpStatus } from \"./lib\";\n\nexport default async () => {\n  try {\n    const statusResult = await getWarpStatus();\n    if (statusResult.status === ConnectionStatus.Connected) {\n      await showHUD(\"Already connected\", {\n        clearRootSearch: true,\n        popToRootType: PopToRootType.Immediate,\n      });\n      return;\n    }\n    const connectionResult = await connectToWarp();\n    if (connectionResult) {\n      await showHUD(\"Connected\", {\n        clearRootSearch: true,\n        popToRootType: PopToRootType.Immediate,\n      });\n      return;\n    }\n\n    throw new Error(\"Failed to connect\");\n  } catch (e) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to connect\",\n    });\n  }\n};\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { exec } from \"child_process\";\nimport util from \"util\";\nconst execPromise = util.promisify(exec);\n\nconst preferences: { wrapCliPath: string } = getPreferenceValues();\nconst DEFAULT_WRAP_CLI_PATH = \"/Applications/Cloudflare WARP.app/Contents/Resources/warp-cli\";\nconst wrapCliCmd = preferences.wrapCliPath ?? DEFAULT_WRAP_CLI_PATH;\n\nexport async function execCommand<T>(cmd: string): Promise<T> {\n  const { stdout } = await execPromise(`\"${wrapCliCmd}\" -j ${cmd}`);\n  return JSON.parse(stdout);\n}\n\nexport async function connectToWarp(): Promise<boolean> {\n  try {\n    const { status } = await execCommand<{ status: string }>(\"connect\");\n    if (status === \"Success\") {\n      return true;\n    }\n    throw new Error(\"Failed to connect\");\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nexport async function disconnectFromWarp(): Promise<boolean> {\n  try {\n    const { status } = await execCommand<{ status: string }>(\"disconnect\");\n    if (status === \"Success\") {\n      return true;\n    }\n    throw new Error(\"Failed to connect\");\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nexport enum ConnectionStatus {\n  Connected = \"connected\",\n  Disconnected = \"disconnected\",\n  Unknown = \"unknown\",\n}\nexport type StatusResult = {\n  status: ConnectionStatus;\n  disconnectReason: string;\n};\nexport async function getWarpStatus(): Promise<StatusResult> {\n  const { status, reason } = await execCommand<{ status: string; reason?: string }>(\"status\");\n  if (status === \"Disconnected\") {\n    return { status: ConnectionStatus.Disconnected, disconnectReason: reason ?? \"unknown\" };\n  }\n  if (status === \"Connected\") {\n    return { status: ConnectionStatus.Connected, disconnectReason: \"\" };\n  }\n  return { status: ConnectionStatus.Unknown, disconnectReason: \"unknown\" };\n}\n\nexport type VirtualNetwork = {\n  id: string;\n  name: string;\n  description: string;\n  default: boolean;\n  active: boolean;\n};\n\ntype VNetResult = {\n  active_vnet_id: string;\n  virtual_networks: {\n    id: string;\n    name: string;\n    description: string;\n    default: boolean;\n  }[];\n};\nexport async function getVirtualNetworks(): Promise<VirtualNetwork[]> {\n  const { active_vnet_id: activeVnetId, virtual_networks: virtualNetwork } = await execCommand<VNetResult>(\"vnet\");\n  const networks = virtualNetwork.map((network) => {\n    return {\n      id: network.id,\n      name: network.name,\n      description: network.description,\n      default: network.default,\n      active: network.id === activeVnetId,\n    };\n  });\n\n  return networks;\n}\n\nexport async function switchVirtualNetwork(id: string): Promise<boolean> {\n  try {\n    const disconnected = await disconnectFromWarp();\n    if (!disconnected) {\n      throw new Error(\"Failed to disconnect\");\n    }\n    const { status } = await execCommand<{ status: string }>(`vnet ${id}`);\n    if (status !== \"Success\") {\n      throw new Error(\"Failed to switch network\");\n    }\n    const connectStatus = await connectToWarp();\n    if (!connectStatus) {\n      throw new Error(\"Failed to connect\");\n    }\n    return true;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAyD,wBCAzD,IAAAC,EAAoC,wBACpCC,EAAqB,yBACrBC,EAAiB,mBACXC,EAAc,EAAAC,QAAK,UAAU,MAAI,EAEjCC,KAAuC,uBAAoB,EAC3DC,EAAwB,gEACxBC,EAAaF,EAAY,aAAeC,EAE9C,eAAsBE,EAAeC,EAAyB,CAC5D,GAAM,CAAE,OAAAC,CAAO,EAAI,MAAMP,EAAY,IAAII,CAAU,QAAQE,CAAG,EAAE,EAChE,OAAO,KAAK,MAAMC,CAAM,CAC1B,CAEA,eAAsBC,GAAkC,CACtD,GAAI,CACF,GAAM,CAAE,OAAAC,CAAO,EAAI,MAAMJ,EAAgC,SAAS,EAClE,GAAII,IAAW,UACb,MAAO,GAET,MAAM,IAAI,MAAM,mBAAmB,CACrC,OAASC,EAAG,CACV,eAAQ,MAAMA,CAAC,EACR,EACT,CACF,CAwBA,eAAsBC,GAAuC,CAC3D,GAAM,CAAE,OAAAC,EAAQ,OAAAC,CAAO,EAAI,MAAMC,EAAiD,QAAQ,EAC1F,OAAIF,IAAW,eACN,CAAE,OAAQ,eAA+B,iBAAkBC,GAAU,SAAU,EAEpFD,IAAW,YACN,CAAE,OAAQ,YAA4B,iBAAkB,EAAG,EAE7D,CAAE,OAAQ,UAA0B,iBAAkB,SAAU,CACzE,CDvDA,IAAOG,EAAQ,SAAY,CACzB,GAAI,CAEF,IADqB,MAAMC,EAAc,GACxB,SAAW,YAA4B,CACtD,QAAM,WAAQ,oBAAqB,CACjC,gBAAiB,GACjB,cAAe,gBAAc,SAC/B,CAAC,EACD,MACF,CAEA,GADyB,MAAMC,EAAc,EACvB,CACpB,QAAM,WAAQ,YAAa,CACzB,gBAAiB,GACjB,cAAe,gBAAc,SAC/B,CAAC,EACD,MACF,CAEA,MAAM,IAAI,MAAM,mBAAmB,CACrC,MAAY,CACV,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,mBACT,CAAC,CACH,CACF",
  "names": ["connect_exports", "__export", "connect_default", "__toCommonJS", "import_api", "import_api", "import_child_process", "import_util", "execPromise", "util", "preferences", "DEFAULT_WRAP_CLI_PATH", "wrapCliCmd", "execCommand", "cmd", "stdout", "connectToWarp", "status", "e", "getWarpStatus", "status", "reason", "execCommand", "connect_default", "getWarpStatus", "connectToWarp"]
}
